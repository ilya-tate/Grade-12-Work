What is Node.js
    - Node is an environment that allows us to run JS outside of the browser.
    - Built using chrome's V8 JS engine.
    - Node has a large and great community that is adding to the libraries available.

Differences from Browser to Node
    - There is no DOM (dom calls error out).
    - There is no Window.
    - This runs server side apps.
    - Great for filesystem (accessing the computer not just the browser).
    - Versioning (the version is static so there is no chance of breaking with future updates).
    - They use commonJS so we don't need to worry about ES6 or browser compatibility.

Installing NodeJS
- If you are going to install this on your own computer you should always use the LTS (long term support) version.

REPL and CLI
    - REPL(Read Eval Print Loop) is a terminal command that lets us use Node.
    - CLI (Command Line Interface) is the better way that we can use Node.

REPL
    - REPL is kind of like having a small IDE in your terminal you can create variables and call them in the terminal but this is very inefficient and just for playing around.

CLI
    - This is the version that runs js files and compiles them for the terminal.
    - If you type 'node filename.js' the file will be compiled and run without the need for a browser engine.

Globals
    - Just like JS, there are several global variables that we are able to use anywhere.
    - For instance 'console' we dont need to define this, node already knows.
    - Here are a few globals that you should know.
    __dirname (with 2 _'s) - Path to current directory.
    __filename (with 2 _'s) - The current file name.
    require - Allows us to use modules.
    module - Info about the current module.
    process - Info about the env where the program is being executed.

Built-In Modules
    - There are a lot of built in modules that are useful for different programs.
    - We are going to be using four main ones, but you can find more in the docs if you want to make your own projects.

OS Module
    - The OS module is used to return information on the computer and system information on hte PC.
    Ex.
        const os = require("os");

Path Module
    - The Path module is used for navigating the directories and file paths.
    - This also includes methods that will clean up paths to avoid errors.
    Ex.
        const path = require("path");

FS (File System) Module
    - The file system module is extensive and allows interation between your code and the files on your computer.
    - This has methods to allow reading, writing, cleaning, and combining files (and so much more).
    - Because it is so extensive we only import what we need.
    Ex.
        const { readFileSync, writeFileSync} = require("fs");

HTTP Module
    - HTTP is all about servers and internet protocol.
    - This library truncate a lot of difficult code into simpler methods and never buffers requests or responses, allowing users to stream data.
    Ex.
        const http = require("http");

Nodemon
    - Nodemon is a dev dependency that we use to help with node server development.
    - If you ever update any files on a server then you need to stop and restart the server to load those settings.
    - Nodemon lets us do it automatically.

NPM Scripts
    - If you look into your package.json you will also see a "scripts" object.
    - We have been using this in react without even knowing it you may recognize the commands listed.

Testing Script
    - Please test your script now, using npm to run the script.
    - Make sure it starts up the nodemon server and continues to run.
    - If a script fails to run it is smart to check "npm run" as well, some CLI commands requires the run keyword.

Event Loop
    - The event loop is a key part of how the browser works with async functions and callbacks.

Async
    - As we saw there ar esome functions that run outside of the call stack in a browser API.
    - Any code that is running / operating outside of the call stack is called asynchronous.
    - We can force functions to be async, allowing our code to keep running without waiting for the function to finish.

Node Event Loop
    - Node recreated this event loop process for their own library.
    - This allows node to handle several requests at the same time without running into delays or blockages.

Hypertext Transfer Protocol
    - HTTP is how we send information from a browser or a URL to a server.
    - HTTP is the typical way that users ask for information from a server and that is called a request.

http Module
    - Node is excellent at server setup and request handling, this is done through the http module.
    - Here we have methods like http.createServer() that allow us to easily create a new server.

createServer()
    - "http.createServer()" takes in a call back function with 2 parameters, one for requests, and one for a response.
    Ex.
        const server = http.createServer((req, res) => {
            // Code
        });

Req and Res
    - Req is an object representing the http request, typically done through the url but also through things like fetch().
    - Res is the response, or what the server returns to the user to use.
    Ex.
        const server = http.createServer((req, res) => {
            // Code
        });

The Request Object
    - There is a lot of information stored in the request object, including url, header, and params.
    - We are going to start with the url to get the location of the page we are querying.
    Ex.
        if (req.url === "/") return;
    - The response object has a ton of information as well, including format, json, and download.
    - We are going to focus on the required one called ".end" that ends the response process.
    Ex.
        res.end("Welcome to our home page");
        else { res.status(404).end(); }

Promises
    - Promises are a special object that holds information about the values received but also whether or not the operation is finished.
    - Promises are asynchronous so we can use them to run code and then we can force the code to wait on the promise.
    - Async / Await is a way that we can use promises.
    - "await" is a keyword telling us that we are going to await for the promise to finish and return information.
    - Not everything has a promise on it, fetch is a promise by default but things like large math problems are not promises.
    - Promises are objects so we can set them up like any other object.
    Ex.
        const getText = path => {
            return new Promise((resolve, reject) => /* Code */);
        }
    - Promises have always been very important for js and other async languages.
    - We are going to see 3 ways to handle promises but please only use async / await in the future.

Events
    - Events are triggered by use input, just like js or html events like onClick().
    - Node uses events very often building modules that handle changes on the page.
    - In node events are built off of a singular module called the event emitter.
    - This module takes in some kind of request and gives back something depending on the parameters.
    - The common events are requests and we use a method called ".on()" for that.
    - Any other module that extends events is also able to use the ".on()" for example the http servers.

File System Flags
    - When creating files sequentially we need to tell node how we want the data exported, i.e. overwrite, append, create only if it doesn't exist etc.
    - Here are some common ones.
    w - Open file for writing (overwrites the file).
    a - Open file for appending (adds to the file).
    r - Open file for reading (you can't change the file when you use this flag).

Streams
    - You have likely heard of streaming tc, movies, and music on your phone.
    - Streaming is a technical term that means to do something sequentially.
    - We only load 64 kb of information at a time so we can enjoy the loaded part while the rest is loading.

Streaming Options
    - Just like fs options with flags, there are options with streaming as well the big two ones are.
    highWaterMark - Tells the stream how many bytes should be in each chunk.
    encoding - Defines the language, "utf8" for example.

Servers
    - Servers are computers, I know they sound more advanced and technical, but they are a computer just like your laptop.
    - The only difference is that a server is meant to stay on always and have the resources they are carrying available.

HTTP Request Cycle
    - Urls are an address to the server where the information is stored.
    - Think of it like a house and you need to send a letter to ask for something, you can't do that without knowing the address.
    - The url holds a lot of information, where to go and what to ask for.
    - The server waits for this HTTP request and then HTTP responds with the corresponding data if available.

Request Messages
    - A request has four parts.
    Method - GET, PUT, POST, DELETE
    Url - The address to go to.
    Headers - The options that your request carries.
    Body - Any other relevant information needed.
    - CRUD
    Get - Read data
    Post - Create data
    Put - Update data
    Delete - Delete data

Headers (optional)
    - A header is an object the is filled with key value pairs describing the request.

Body or Payload (optional)
    - This is the content that you are depositing onto the server if you are running a PUT or POST request.
    - This is totally optional and the user can't do this with a url request, you would need to set up this command using a form or something.

Response Messages
    - This is very similar to the request message.
    Status Code - 200, 404, etc. tells the user the status.
    Status Text - Describes the code, OK or Page not found.
    Headers - Details about the data and server.
    Body - The content they want, HTML, JSON, etc.

Server Status Codes
    100's Information - This is a preliminary response, typically used to let the client know that their request was received and to wait.
    200's Success - This is a success, there are a lot of codes in the 200, but all of them are just different types of successes.
    300's Redirect - These are redirection, this is typically placed by the dev to handle deprecations. For Example 301 is moved permanently and the dev displays the new URL.
    400's Client Errors - This is used when the error seems to be caused by the client and not the server.
    500's Server Errors - These are reserved for when something goes wrong in the server's code, infinite loops, missing methods, etc.

MIME Types
    - Mime types tell the browser how to encode the information that it is responding with.
    - Some well known ones are text, JSON, css, html. Look them up in MDN for more.

API vs SSR
    - There are two main things that you can do with a server.
    - You can set up an API with json data or you can set up a website using server side rendering.

API
    - APIs are used to return to the client in a response using the res.json().
    - This is used to send data and store data.

SSR
    - This is also easily served using res.render().
    - This is used to serve templates of the page from the server.

Express JSON
    - When serving a JSON file you need to encode the text to be application/json.
    - Express responses have a method for this too, res.json().

req.params
    - Url routes can include a:to represent a unique param and we can use that from the req object.
    Ex.
        test/users/:id => test/users/1234
    - If we check req.params we receive "{ id: 1234 }".

res.query
    - For more complicated searches you can use query, you can add any or all query params to this.
    Ex.
        test/api/query => test/api/query?id=123
    - req.query returns an object with property id "{ id: 123 }".
